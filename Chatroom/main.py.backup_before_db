from flask import Flask, render_template, request, jsonify, session
from flask_socketio import SocketIO, emit, join_room, leave_room
from dotenv import load_dotenv
import os
from datetime import datetime, timezone
from functools import wraps

load_dotenv('chatroom/.env')

app = Flask(__name__, static_folder='static', template_folder='templates')
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY', 'dev-secret-key')
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'

socketio = SocketIO(
    app,
    cors_allowed_origins=os.getenv('SOCKETIO_CORS_ORIGINS', '*'),
    async_mode='threading',
    logger=True,
    engineio_logger=True
)

users = {}
friendships = set()
friend_requests = []
conversations = {}
messages = {}
online_users = {}
user_sockets = {}

def get_next_id(collection):
    if isinstance(collection, dict):
        return max(collection.keys(), default=0) + 1
    elif isinstance(collection, list):
        return max([item['id'] for item in collection], default=0) + 1
    return 1

def normalize_friend_pair(user_id_a, user_id_b):
    return tuple(sorted([user_id_a, user_id_b]))

def are_friends(user_id_a, user_id_b):
    return normalize_friend_pair(user_id_a, user_id_b) in friendships

def get_or_create_conversation(user_id_a, user_id_b):
    if not are_friends(user_id_a, user_id_b):
        return None
    participant_set = {user_id_a, user_id_b}
    for conv_id, conv in conversations.items():
        if conv['type'] == 'direct' and set(conv['participant_ids']) == participant_set:
            return conv_id
    conv_id = get_next_id(conversations)
    conversations[conv_id] = {
        'id': conv_id,
        'type': 'direct',
        'participant_ids': [user_id_a, user_id_b],
        'created_at': datetime.now(timezone.utc).isoformat()
    }
    messages[conv_id] = []
    return conv_id

def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return jsonify({'error': 'Unauthorized'}), 401
        return f(*args, **kwargs)
    return decorated_function

def socket_login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        socket_id = request.sid
        if socket_id not in user_sockets:
            emit('error', {'message': 'Unauthorized'})
            return
        return f(*args, **kwargs)
    return decorated_function

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/auth/dev-login', methods=['POST'])
def dev_login():
    if os.getenv('AUTH_MODE') != 'mock':
        return jsonify({'error': 'Mock login disabled'}), 403
    data = request.json
    display_name = data.get('display_name', 'Anonymous')
    user_id = None
    for uid, user in users.items():
        if user['display_name'] == display_name:
            user_id = uid
            break
    if user_id is None:
        user_id = get_next_id(users)
        users[user_id] = {
            'id': user_id,
            'display_name': display_name,
            'avatar_url': f'https://ui-avatars.com/api/?name={display_name}&background=random',
            'email': None,
            'last_seen': datetime.now(timezone.utc).isoformat()
        }
    session['user_id'] = user_id
    return jsonify({'user': users[user_id], 'message': 'Login successful'})

@app.route('/auth/logout', methods=['POST'])
@login_required
def logout():
    user_id = session.pop('user_id', None)
    return jsonify({'message': 'Logout successful'})

@app.route('/api/me', methods=['GET'])
@login_required
def get_current_user():
    user_id = session['user_id']
    return jsonify({'user': users.get(user_id)})

@app.route('/api/users', methods=['GET'])
@login_required
def get_users():
    current_user_id = session['user_id']
    user_list = [{**user, 'is_online': user['id'] in online_users} for user in users.values() if user['id'] != current_user_id]
    return jsonify({'users': user_list})

@app.route('/api/friends', methods=['GET'])
@login_required
def get_friends():
    user_id = session['user_id']
    friend_list = []
    for pair in friendships:
        friend_id = None
        if pair[0] == user_id:
            friend_id = pair[1]
        elif pair[1] == user_id:
            friend_id = pair[0]
        if friend_id:
            friend = users.get(friend_id)
            if friend:
                friend_list.append({**friend, 'is_online': friend_id in online_users})
    return jsonify({'friends': friend_list})

@app.route('/api/friend-requests', methods=['GET'])
@login_required
def get_friend_requests():
    user_id = session['user_id']
    received = [{**req, 'from_user': users.get(req['from_user_id'])} for req in friend_requests if req['to_user_id'] == user_id and req['status'] == 'pending']
    sent = [{**req, 'to_user': users.get(req['to_user_id'])} for req in friend_requests if req['from_user_id'] == user_id and req['status'] == 'pending']
    return jsonify({'received': received, 'sent': sent})

@app.route('/api/friend-requests', methods=['POST'])
@login_required
def send_friend_request():
    user_id = session['user_id']
    data = request.json
    to_user_id = data.get('to_user_id')
    if not to_user_id or to_user_id not in users:
        return jsonify({'error': 'User not found'}), 404
    if are_friends(user_id, to_user_id):
        return jsonify({'error': 'Already friends'}), 400
    for req in friend_requests:
        if req['from_user_id'] == user_id and req['to_user_id'] == to_user_id:
            return jsonify({'error': 'Request already sent'}), 400
    req_id = get_next_id(friend_requests)
    new_request = {'id': req_id, 'from_user_id': user_id, 'to_user_id': to_user_id, 'status': 'pending', 'created_at': datetime.now(timezone.utc).isoformat()}
    friend_requests.append(new_request)
    if to_user_id in online_users:
        socketio.emit('friend_request:new', {'request': {**new_request, 'from_user': users[user_id]}}, room=online_users[to_user_id])
    return jsonify({'request': new_request})

@app.route('/api/friend-requests/<int:request_id>', methods=['PATCH'])
@login_required
def respond_friend_request(request_id):
    user_id = session['user_id']
    data = request.json
    action = data.get('action')
    if action not in ['accepted', 'declined']:
        return jsonify({'error': 'Invalid action'}), 400
    req = next((r for r in friend_requests if r['id'] == request_id), None)
    if not req:
        return jsonify({'error': 'Request not found'}), 404
    if req['to_user_id'] != user_id:
        return jsonify({'error': 'Unauthorized'}), 403
    req['status'] = action
    req['acted_at'] = datetime.now(timezone.utc).isoformat()
    if action == 'accepted':
        friendships.add(normalize_friend_pair(req['from_user_id'], req['to_user_id']))
        if req['from_user_id'] in online_users:
            socketio.emit('friend_request:accepted', {'user': users[user_id]}, room=online_users[req['from_user_id']])
    return jsonify({'request': req})

@app.route('/api/conversations', methods=['GET'])
@login_required
def get_conversations():
    user_id = session['user_id']
    conv_list = []
    for conv in conversations.values():
        if user_id in conv['participant_ids']:
            other_user_id = next(uid for uid in conv['participant_ids'] if uid != user_id)
            other_user = users.get(other_user_id)
            conv_messages = messages.get(conv['id'], [])
            last_message = conv_messages[-1] if conv_messages else None
            conv_list.append({'id': conv['id'], 'type': conv['type'], 'other_user': {**other_user, 'is_online': other_user_id in online_users}, 'last_message': last_message, 'unread_count': 0})
    conv_list.sort(key=lambda c: c['last_message']['created_at'] if c['last_message'] else '', reverse=True)
    return jsonify({'conversations': conv_list})

@app.route('/api/conversations/<int:conversation_id>/messages', methods=['GET'])
@login_required
def get_messages_route(conversation_id):
    user_id = session['user_id']
    conv = conversations.get(conversation_id)
    if not conv or user_id not in conv['participant_ids']:
        return jsonify({'error': 'Conversation not found'}), 404
    conv_messages = messages.get(conversation_id, [])
    enriched_messages = [{**msg, 'sender': users.get(msg['sender_id'])} for msg in conv_messages]
    return jsonify({'messages': enriched_messages})

@socketio.on('connect')
def handle_connect():
    print(f'Client connected: {request.sid}')
    emit('connected', {'message': 'Connected to server'})

@socketio.on('authenticate')
def handle_authenticate(data):
    user_id = session.get('user_id')
    if not user_id:
        emit('error', {'message': 'Not authenticated'})
        return
    if user_id not in users:
        emit('error', {'message': 'Session expired. Please login again.'})
        return
    socket_id = request.sid
    user_sockets[socket_id] = user_id
    online_users[user_id] = socket_id
    users[user_id]['last_seen'] = datetime.now(timezone.utc).isoformat()
    for pair in friendships:
        friend_id = None
        if pair[0] == user_id:
            friend_id = pair[1]
        elif pair[1] == user_id:
            friend_id = pair[0]
        if friend_id and friend_id in online_users:
            socketio.emit('user:online', {'user_id': user_id, 'user': users[user_id]}, room=online_users[friend_id])
    emit('authenticated', {'user': users[user_id]})
    print(f'User {user_id} authenticated on socket {socket_id}')

@socketio.on('disconnect')
def handle_disconnect():
    socket_id = request.sid
    user_id = user_sockets.pop(socket_id, None)
    if user_id:
        online_users.pop(user_id, None)
        users[user_id]['last_seen'] = datetime.now(timezone.utc).isoformat()
        for pair in friendships:
            friend_id = None
            if pair[0] == user_id:
                friend_id = pair[1]
            elif pair[1] == user_id:
                friend_id = pair[0]
            if friend_id and friend_id in online_users:
                socketio.emit('user:offline', {'user_id': user_id, 'last_seen': users[user_id]['last_seen']}, room=online_users[friend_id])
        print(f'User {user_id} disconnected')

@socketio.on('message:send')
@socket_login_required
def handle_send_message(data):
    socket_id = request.sid
    sender_id = user_sockets[socket_id]
    recipient_id = data.get('recipient_id')
    content = data.get('content', '').strip()
    if not content:
        emit('error', {'message': 'Message content cannot be empty'})
        return
    if not are_friends(sender_id, recipient_id):
        emit('error', {'message': 'You can only message friends'})
        return
    conversation_id = get_or_create_conversation(sender_id, recipient_id)
    message_id = len(messages.get(conversation_id, [])) + 1
    new_message = {'id': message_id, 'conversation_id': conversation_id, 'sender_id': sender_id, 'content': content, 'created_at': datetime.now(timezone.utc).isoformat()}
    if conversation_id not in messages:
        messages[conversation_id] = []
    messages[conversation_id].append(new_message)
    enriched_message = {**new_message, 'sender': users[sender_id]}
    emit('message:new', enriched_message)
    if recipient_id in online_users:
        socketio.emit('message:new', enriched_message, room=online_users[recipient_id])
    print(f'Message sent: {sender_id} -> {recipient_id}: {content}')

@socketio.on('typing:start')
@socket_login_required
def handle_typing_start(data):
    socket_id = request.sid
    user_id = user_sockets[socket_id]
    recipient_id = data.get('recipient_id')
    if recipient_id in online_users:
        socketio.emit('typing:start', {'user_id': user_id, 'user': users[user_id]}, room=online_users[recipient_id])

@socketio.on('typing:stop')
@socket_login_required
def handle_typing_stop(data):
    socket_id = request.sid
    user_id = user_sockets[socket_id]
    recipient_id = data.get('recipient_id')
    if recipient_id in online_users:
        socketio.emit('typing:stop', {'user_id': user_id}, room=online_users[recipient_id])

if __name__ == '__main__':
    port = int(os.getenv('PORT', 5000))
    host = os.getenv('HOST', '127.0.0.1')
    debug = os.getenv('FLASK_DEBUG', '1') == '1'
    print(f'Starting server on {host}:{port}')
    print(f'Auth mode: {os.getenv("AUTH_MODE", "mock")}')
    socketio.run(app, host=host, port=port, debug=debug)
